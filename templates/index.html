<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portuguese Verb Conjugation Practice</title>
    <link rel="stylesheet" href="/static/style.css">
    <script>
        const IRREGULAR_VERBS = {{ irregular_verbs | tojson }};
        const REGULAR_VERBS = {{ regular_verbs | tojson }};
    </script>
</head>
<body>
    <header class="header">
        <div class="logo-container">
            <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM0Q0FGNTAiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMyAxMWwxOC0xbC0xMCA4TDMgMTF6Ii8+PHBhdGggZD0iTTExIDE4bDQtNiIvPjwvc3ZnPg==" alt="Logo" class="logo">
            <span class="logo-text">Verb Master</span>
        </div>
        <div class="auth-buttons">
            <a href="#" class="auth-button login-button">Login</a>
            <a href="#" class="auth-button register-button">Register</a>
        </div>
    </header>
    
    <div class="container">
        <nav class="nav-panel">
    <a href="/?verb_type=irregular&tense=presente_do_indicativo" class="nav-item {% if selected_verb_type == 'irregular' and selected_tense == 'presente_do_indicativo' %}active{% endif %}">Irregular: Presente do Indicativo</a>
    <a href="/?verb_type=irregular&tense=preterito_perfeito" class="nav-item {% if selected_verb_type == 'irregular' and selected_tense == 'preterito_perfeito' %}active{% endif %}">Irregular: Pretérito Perfeito Simples</a>
    <a href="/?verb_type=irregular&tense=preterito_imperfeito" class="nav-item {% if selected_verb_type == 'irregular' and selected_tense == 'preterito_imperfeito' %}active{% endif %}">Irregular: Pretérito Imperfeito</a>
    <a href="/?verb_type=irregular&tense=preterito_mais_que_perfeito" class="nav-item {% if selected_verb_type == 'irregular' and selected_tense == 'preterito_mais_que_perfeito' %}active{% endif %}">Irregular: Pretérito Mais-que-perfeito</a>
    <a href="/?verb_type=irregular&tense=futuro_simples_do_indicativo" class="nav-item {% if selected_verb_type == 'irregular' and selected_tense == 'futuro_simples_do_indicativo' %}active{% endif %}">Irregular: Futuro Simples do Indicativo</a>
    <a href="/?verb_type=regular&tense=presente_do_indicativo" class="nav-item {% if selected_verb_type == 'regular' and selected_tense == 'presente_do_indicativo' %}active{% endif %}">Regular: Presente do Indicativo</a>
    <a href="/?verb_type=regular&tense=preterito_perfeito" class="nav-item {% if selected_verb_type == 'regular' and selected_tense == 'preterito_perfeito' %}active{% endif %}">Regular: Pretérito Perfeito Simples</a>
    <a href="/?verb_type=regular&tense=preterito_imperfeito" class="nav-item {% if selected_verb_type == 'regular' and selected_tense == 'preterito_imperfeito' %}active{% endif %}">Regular: Pretérito Imperfeito</a>
    <a href="/?verb_type=regular&tense=preterito_mais_que_perfeito" class="nav-item {% if selected_verb_type == 'regular' and selected_tense == 'preterito_mais_que_perfeito' %}active{% endif %}">Regular: Pretérito Mais-que-perfeito</a>
    <a href="/?verb_type=regular&tense=futuro_simples_do_indicativo" class="nav-item {% if selected_verb_type == 'regular' and selected_tense == 'futuro_simples_do_indicativo' %}active{% endif %}">Regular: Futuro Simples do Indicativo</a>
</nav>
        
        <div class="main-content">
            <h1>Portuguese Verb Conjugation Practice</h1>
<div class="score">Score: <span id="score">0</span></div>

<div class="controls">
    <button class="btn btn-reset" id="resetButton">Reset Game</button>
</div>

<div class="special-chars">
    <button class="special-char-btn">á</button>
    <button class="special-char-btn">à</button>
    <button class="special-char-btn">â</button>
    <button class="special-char-btn">ã</button>
    <button class="special-char-btn">é</button>
    <button class="special-char-btn">ê</button>
    <button class="special-char-btn">í</button>
    <button class="special-char-btn">ó</button>
    <button class="special-char-btn">ô</button>
    <button class="special-char-btn">õ</button>
    <button class="special-char-btn">ú</button>
    <button class="special-char-btn">ç</button>
</div>

{% set tense_names = {
    'presente_do_indicativo': 'Presente do Indicativo',
    'preterito_perfeito': 'Pretérito Perfeito Simples',
    'preterito_imperfeito': 'Pretérito Imperfeito',
    'preterito_mais_que_perfeito': 'Pretérito Mais-que-perfeito do Indicativo',
    'futuro_simples_do_indicativo': 'Futuro Simples do Indicativo'
} %}

{% if selected_verb_type == 'irregular' %}
    <h2>Irregular Verbs: {{ tense_names[selected_tense] }}</h2>
    <table class="conjugation-table" id="irregular-table">
        <thead>
            <tr>
                <th>Person</th>
            </tr>
        </thead>
        <tbody id="irregular-table-body">
        </tbody>
    </table>
    <script>
    // --- Механика динамического отображения только 5 незаполненных глаголов ---
    console.log('IRREGULAR_VERBS:', IRREGULAR_VERBS); // Диагностика: убедитесь, что объект не пустой
    const CURRENT_TENSE = "{{ selected_tense }}";
    const PERSONS = ['eu', 'tu', 'ele', 'nós', 'eles'];
    const MAX_VISIBLE = 5;

    // Получить список полностью заполненных глаголов
    function getCompletedVerbs(tense) {
        try {
            return JSON.parse(localStorage.getItem('conj_progress_' + tense)) || [];
        } catch { return []; }
    }
    // Пометить глагол как полностью заполненный
    function markVerbCompleted(verb, tense) {
        let completed = getCompletedVerbs(tense);
        if (!completed.includes(verb)) {
            completed.push(verb);
            localStorage.setItem('conj_progress_' + tense, JSON.stringify(completed));
        }
    }
    // Получить список глаголов для отображения (5 незаполненных, если есть)
    function getVisibleVerbs(allVerbs, tense) {
        const completed = getCompletedVerbs(tense);
        return allVerbs.filter(v => !completed.includes(v)).slice(0, MAX_VISIBLE);
    }
    // Проверить, заполнена ли колонка (все поля правильные)
    function isColumnCompleted(verb) {
        for (const person of PERSONS) {
            const input = document.querySelector(`.conjugation-input[data-verb='${verb}'][data-person='${person}']`);
            if (!input || !input.classList.contains('correct')) return false;
        }
        return true;
    }
    // Перерисовать таблицу
    function renderIrregularTable(focusInfo=null) {
        const allVerbs = Object.keys(IRREGULAR_VERBS);
        const visibleVerbs = getVisibleVerbs(allVerbs, CURRENT_TENSE);
        // Заголовки
        let thead = document.querySelector('#irregular-table thead tr');
        thead.innerHTML = '<th>Person</th>' + visibleVerbs.map(v => `<th>${v}</th>`).join('');
        // Тело
        let tbody = document.getElementById('irregular-table-body');
        tbody.innerHTML = '';
        for (const person of PERSONS) {
            let row = `<tr><td>${person}</td>`;
            for (const verb of visibleVerbs) {
                const answer = IRREGULAR_VERBS[verb][CURRENT_TENSE]?.[person] || '';
                row += `<td><input type="text" class="conjugation-input" data-verb="${verb}" data-tense="${CURRENT_TENSE}" data-person="${person}" data-answer="${answer}"></td>`;
            }
            row += '</tr>';
            tbody.innerHTML += row;
        }
        attachInputHandlers();
        attachDblClickToAllInputs(); // Явно навесить двойной клик после перерисовки
        if (focusInfo) {
            // После скрытия колонки: переносим фокус на нужный input
            const { nextVerb, person } = focusInfo;
            if (nextVerb && person) {
                const nextInput = document.querySelector(`.conjugation-input[data-verb='${nextVerb}'][data-person='${person}']`);
                if (nextInput) {
                    nextInput.focus();
                    lastFocusedInput = nextInput;
                }
            }
        }
    }
    // Обработчики для input
    function attachDblClickToAllInputs() {
        document.querySelectorAll('.conjugation-input').forEach(input => {
        if (input._dblClickHandler) {
            input.removeEventListener('dblclick', input._dblClickHandler);
        }
        const handler = function() {
            if (!input.dataset.answer) {
                // Кастомный popup
                let popup = document.createElement('div');
                popup.textContent = 'Нет данных для этой формы!';
                popup.style.position = 'fixed';
                popup.style.top = '40%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.background = '#ffdddd';
                popup.style.color = '#a00';
                popup.style.padding = '20px 30px';
                popup.style.borderRadius = '8px';
                popup.style.boxShadow = '0 2px 12px rgba(0,0,0,0.15)';
                popup.style.zIndex = 10000;
                document.body.appendChild(popup);
                setTimeout(() => popup.remove(), 1800);
                return;
            }
            input.value = input.dataset.answer;
            input.classList.add('show-answer');
            setTimeout(() => input.classList.remove('show-answer'), 1200);
        };
        input.addEventListener('dblclick', handler);
        input._dblClickHandler = handler;
        input.dataset.dblclickBound = '1';
        console.log('dblclick attached', input.dataset.verb, input.dataset.tense, input.dataset.person);
    });
        document.querySelectorAll('.conjugation-input').forEach(input => {
            if (!input.dataset.dblclickBound) {
                input.addEventListener('dblclick', function() {
                    input.value = input.dataset.answer;
                    input.classList.add('show-answer');
                    setTimeout(() => input.classList.remove('show-answer'), 1200);
                });
                input.dataset.dblclickBound = '1';
            }
        });
    }
    
    function attachInputHandlers() {
        document.querySelectorAll('.conjugation-input').forEach(input => {
            input.addEventListener('focus', () => {
                lastFocusedInput = input;
            });
            input.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const response = await fetch('/check', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            verb: input.dataset.verb,
                            tense: input.dataset.tense,
                            person: input.dataset.person,
                            answer: input.value
                        })
                    });
                    const result = await response.json();
                    if (result.correct) {
                        input.classList.add('correct');
                        input.classList.remove('incorrect');
                        // --- Автофокус на следующую ячейку (person) в этом столбце (verb) ---
                        const persons = PERSONS;
                        const curPersonIdx = persons.indexOf(input.dataset.person);
                        const verb = input.dataset.verb;
                        let nextInput = null;
                        if (curPersonIdx !== -1 && curPersonIdx < persons.length - 1) {
                            // Следующая строка (person) в этом же столбце
                            nextInput = document.querySelector(`.conjugation-input[data-verb='${verb}'][data-person='${persons[curPersonIdx+1]}']`);
                        } else {
                            // Первая строка следующей незаполненной колонки
                            const allVerbs = Object.keys(IRREGULAR_VERBS);
                            const visibleVerbs = getVisibleVerbs(allVerbs, CURRENT_TENSE);
                            const idx = visibleVerbs.indexOf(verb);
                            let nextVerb = null;
                            if (idx !== -1 && idx < visibleVerbs.length - 1) {
                                nextVerb = visibleVerbs[idx + 1];
                            }
                            if (nextVerb) {
                                nextInput = document.querySelector(`.conjugation-input[data-verb='${nextVerb}'][data-person='eu']`);
                            }
                        }
                        if (nextInput) {
                            setTimeout(() => { nextInput.focus(); lastFocusedInput = nextInput; }, 100);
                        }
                    } else {
                        input.classList.add('incorrect');
                        input.classList.remove('correct');
                    }
                    // После проверки — если вся колонка заполнена, скрыть её и показать новую
                    const verb = input.dataset.verb;
                    if (isColumnCompleted(verb)) {
                        markVerbCompleted(verb, CURRENT_TENSE);
                        // Найти следующую колонку (глагол) до скрытия
                        const allVerbs = Object.keys(IRREGULAR_VERBS);
                        const visibleVerbs = getVisibleVerbs(allVerbs, CURRENT_TENSE);
                        const idx = visibleVerbs.indexOf(verb);
                        let focusVerb = null;
                        if (idx !== -1 && idx < visibleVerbs.length - 1) {
                            // Следующая после скрытой
                            focusVerb = visibleVerbs[idx + 1];
                        } else if (visibleVerbs.length > 1) {
                            // Если скрытая была последней — фокус на первую видимую
                            focusVerb = visibleVerbs[0] === verb ? visibleVerbs[1] : visibleVerbs[0];
                        }
                        const focusInfo = focusVerb ? { nextVerb: focusVerb, person: 'eu' } : null;
                        setTimeout(() => renderIrregularTable(focusInfo), 300);
                        return;
                    }
                }
            });
        });
        attachDblClickToAllInputs();
}
// Экранная клавиатура — работает с динамическими инпутами
    document.querySelectorAll('.special-char-btn').forEach(button => {
        button.onclick = (event) => {
                let targetInput = lastFocusedInput;
                if (!targetInput || !targetInput.classList.contains('conjugation-input')) {
                    targetInput = document.querySelector('.conjugation-input');
                    if (targetInput) {
                        lastFocusedInput = targetInput;
                    } else {
                        return;
                    }
                }
                let currentText = targetInput.value || '';
                let newText = currentText + button.textContent;
                targetInput.value = newText;
                targetInput.focus();
                event.preventDefault();
            };
        });
    
    // Первичная отрисовка
    renderIrregularTable(); // Важно: должен быть вне всех функций!
    </script>
{% elif selected_verb_type == 'regular' %}
    <h2>Regular Verbs: {{ tense_names[selected_tense] }}</h2>
    <table class="conjugation-table">
        <thead>
            <tr>
                <th>Person</th>
                {% for verb in regular_verbs.keys() %}
                <th>{{ verb }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
            {% for person in ['eu', 'tu', 'ele', 'nós', 'eles'] %}
            <tr>
                <td>{{ person }}</td>
                {% for verb in regular_verbs.keys() %}
                <td>
                    <input type="text"
                           class="conjugation-input"
                           data-verb="{{ verb }}"
                           data-tense="{{ selected_tense }}"
                           data-person="{{ person }}"
                           data-answer="{{ regular_verbs[verb].get(selected_tense, {}).get(person, '') }}">
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </tbody>
    </table>

{% endif %}

        </div>
    </div>

    <script>
    // Глобальная переменная для фокуса
    var lastFocusedInput = null;
    // Универсальный обработчик двойного клика для всех conjugation-input
    function attachDblClickToAllInputs() {      
        document.querySelectorAll('.conjugation-input').forEach(input => {
                if (input._dblClickHandler) {
                input.removeEventListener('dblclick', input._dblClickHandler);
            }
            const handler = function() {
                input.value = input.dataset.answer;
                input.classList.add('show-answer');
                setTimeout(() => input.classList.remove('show-answer'), 1200);
            };
            input.addEventListener('dblclick', handler);
            input._dblClickHandler = handler;
            input.dataset.dblclickBound = '1';
            console.log('dblclick attached', input.dataset.verb, input.dataset.tense, input.dataset.person);
        });
    }
    window.addEventListener('DOMContentLoaded', function() {
        attachDblClickToAllInputs();
        // Для regular-глаголов: если таблица есть на странице, навесить обработчик
        if (document.querySelector('.conjugation-table')) {
            attachDblClickToAllInputs();
        }
    });
    </script>

    <script>
        let score = 0;
        const scoreElement = document.getElementById('score');
        const resetButton = document.getElementById('resetButton');
        const verbCards = document.querySelectorAll('.verb-card');
        const practiceAreas = document.querySelectorAll('.practice-area');
        

        // Track focus on inputs
        document.querySelectorAll('.conjugation-input').forEach(input => {
            input.addEventListener('focus', () => {
                lastFocusedInput = input;
            });
        });

        // Reset game
        resetButton.addEventListener('click', () => {
            score = 0;
            scoreElement.textContent = score;
            document.querySelectorAll('.conjugation-input').forEach(input => {
                input.value = '';
                input.classList.remove('correct', 'incorrect');
            });
            // Сбросить прогресс для текущего времени
            localStorage.removeItem('conj_progress_' + CURRENT_TENSE);
            // Перерисовать таблицу, если мы в irregular секции
            if (typeof renderIrregularTable === 'function') {
                renderIrregularTable();
            }
        });

        // Verb selection
        verbCards.forEach(card => {
            card.addEventListener('click', () => {

                // Update active states
                verbCards.forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                
                practiceAreas.forEach(area => {
                    area.classList.remove('active');
                    if (area.id === `practice-${verb}`) {
                        area.classList.add('active');
                    }
                });

                // Reset inputs for the selected verb
                document.querySelectorAll(`#practice-${verb} .conjugation-input`).forEach(input => {
                    input.value = '';
                    input.classList.remove('correct', 'incorrect');
                });
            });
        });

        // Special character buttons
        // Сначала удалим все предыдущие обработчики (через свойство)
document.querySelectorAll('.special-char-btn').forEach(button => {
    if (button._specialCharHandler) {
        button.removeEventListener('click', button._specialCharHandler);
    }
    const handler = (event) => {
        let targetInput = lastFocusedInput;
        // If no input was focused before, use the first input of active practice area
        if (!targetInput || !targetInput.classList.contains('conjugation-input')) {
            targetInput = document.querySelector('.practice-area.active .conjugation-input') || document.querySelector('.conjugation-input');
            if (targetInput) {
                lastFocusedInput = targetInput;
            } else {
                return;
            }
        }
        let currentText = targetInput.value || '';
        let newText = currentText + button.textContent;
        targetInput.value = newText;
        targetInput.focus();
        event.preventDefault();
    };
    button.addEventListener('click', handler);
    button._specialCharHandler = handler;
});

        // Handle conjugation inputs
        document.querySelectorAll('.conjugation-input').forEach(input => {
            input.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const response = await fetch('/check', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            verb: input.dataset.verb,
                            tense: input.dataset.tense,
                            person: input.dataset.person,
                            answer: input.value
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.correct) {
                        input.classList.add('correct');
                        input.classList.remove('incorrect');
                        score += 10;
                    } else {
                        input.classList.add('incorrect');
                        input.classList.remove('correct');
                        score -= 5;
                    }
                    scoreElement.textContent = score;

                    // --- Перемещение фокуса вниз или на следующий столбец ---
const persons = ['eu', 'tu', 'ele', 'nós', 'eles'];
const currentPerson = input.dataset.person;
const currentVerb = input.dataset.verb;
const currentTense = input.dataset.tense;
const currentIndex = persons.indexOf(currentPerson);
const allVerbs = Array.from(new Set(Array.from(document.querySelectorAll(`.conjugation-input[data-tense='${currentTense}']`)).map(i => i.dataset.verb)));
const verbIndex = allVerbs.indexOf(currentVerb);

if (currentIndex !== -1 && currentIndex < persons.length - 1) {
    // Есть следующая строка (person) в этом столбце (verb)
    const nextPerson = persons[currentIndex + 1];
    const selector = `.conjugation-input[data-verb='${currentVerb}'][data-tense='${currentTense}'][data-person='${nextPerson}']`;
    const nextInput = document.querySelector(selector);
    if (nextInput) {
        nextInput.focus();
        return;
    }
}
// Если дошли до сюда — либо последняя строка, либо что-то не нашли
if (verbIndex !== -1 && verbIndex < allVerbs.length - 1) {
    // Есть следующий столбец (verb)
    const nextVerb = allVerbs[verbIndex + 1];
    const selector = `.conjugation-input[data-verb='${nextVerb}'][data-tense='${currentTense}'][data-person='eu']`;
    const nextInput = document.querySelector(selector);
    if (nextInput) {
        nextInput.focus();
        return;
    }
}
// Если это последняя ячейка — ничего не делаем
                }
            });

            // Double click to reveal answer
            input.addEventListener('dblclick', () => {
                input.value = input.dataset.answer;
                score -= 15;
                scoreElement.textContent = score;
            });
        });

        // Activate the first verb by default
        if (verbCards.length > 0) {
            verbCards[0].click();
        }
    </script>
</body>
</html>
